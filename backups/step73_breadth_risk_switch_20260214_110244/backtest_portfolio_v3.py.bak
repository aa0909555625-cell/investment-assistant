# -*- coding: utf-8 -*-
"""
Portfolio Backtest v3 (Cross-sectional, dynamic holdings, risk switch, costs)

Backward-compatible with weekly_pipeline.py:
- Accepts --threshold (ignored) so old pipeline won't crash.

Inputs:
- data/all_stocks_daily.csv: date, code, total_score, change_percent
- data/market_snapshot_taiex.csv: date, market_ok, trend_ok, risk_mode (recommended)

Outputs:
- reports/portfolio_backtest_v3.csv
- reports/portfolio_backtest_v3_summary.json
"""
from __future__ import annotations

import argparse
import json
import os
from typing import Dict, List, Set

import numpy as np
import pandas as pd

ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))

def read_csv(path: str) -> pd.DataFrame:
    return pd.read_csv(path, dtype={"code": str, "source": str}, low_memory=False, encoding="utf-8-sig")

def safe_bool(x) -> bool:
    if isinstance(x, bool):
        return x
    s = str(x).strip().lower()
    return s in ("1", "true", "t", "yes", "y")

def write_csv(path: str, df: pd.DataFrame) -> None:
    os.makedirs(os.path.dirname(path), exist_ok=True)
    df.to_csv(path, index=False, encoding="utf-8-sig")

def write_json(path: str, obj: dict) -> None:
    os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(path, "w", encoding="utf-8") as f:
        json.dump(obj, f, ensure_ascii=False, indent=2)

def compute_max_drawdown(equity: np.ndarray) -> float:
    if equity.size == 0:
        return 0.0
    peak = np.maximum.accumulate(equity)
    dd = (equity - peak) / peak
    return float(dd.min())

def compute_sharpe(daily_ret: np.ndarray) -> float:
    if daily_ret.size < 2:
        return 0.0
    mu = daily_ret.mean()
    sd = daily_ret.std(ddof=1)
    if sd == 0:
        return 0.0
    return float((mu / sd) * np.sqrt(252.0))

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--in_csv", default=r"data/all_stocks_daily.csv")
    ap.add_argument("--market_csv", default=r"data/market_snapshot_taiex.csv")
    ap.add_argument("--out_csv", default=r"reports/portfolio_backtest_v3.csv")
    ap.add_argument("--out_json", default=r"reports/portfolio_backtest_v3_summary.json")
    ap.add_argument("--start", default="")
    ap.add_argument("--end", default="")
    ap.add_argument("--init_capital", type=float, default=1_000_000.0)
    ap.add_argument("--holdings_on", type=int, default=15)
    ap.add_argument("--holdings_off", type=int, default=0)
    ap.add_argument("--cost_bps", type=float, default=25.0)
    ap.add_argument("--threshold", type=float, default=None)  # backward-compat; ignored
    args = ap.parse_args()

    df = read_csv(os.path.join(ROOT, args.in_csv))
    need = {"date","code","total_score","change_percent"}
    if not need.issubset(set(df.columns)):
        raise ValueError(f"{args.in_csv} must contain: {sorted(list(need))}")

    df["date"] = df["date"].astype(str)
    df["code"] = df["code"].astype(str)
    df["total_score"] = pd.to_numeric(df["total_score"], errors="coerce").fillna(0.0)
    df["change_percent"] = pd.to_numeric(df["change_percent"], errors="coerce").fillna(0.0)

    dates = sorted(df["date"].unique().tolist())
    if args.start:
        dates = [d for d in dates if d >= args.start]
    if args.end:
        dates = [d for d in dates if d <= args.end]

    if len(dates) < 2:
        out = pd.DataFrame([{
            "date": dates[0] if dates else "",
            "prev_date": "",
            "risk_mode": "RISK_OFF",
            "market_ok": False,
            "trend_ok": False,
            "breadth_ratio": 0.0,
            "holdings": 0,
            "turnover": 0.0,
            "gross_return": 0.0,
            "cost_frac": 0.0,
            "net_return": 0.0,
            "equity": args.init_capital,
        }])
        write_csv(os.path.join(ROOT, args.out_csv), out)
        write_json(os.path.join(ROOT, args.out_json), {
            "init_capital": args.init_capital,
            "final_equity": args.init_capital,
            "total_return": 0.0,
            "annualized_return": 0.0,
            "max_drawdown": 0.0,
            "sharpe": 0.0,
            "bars": max(0, len(dates)-1),
            "note": f"Need >=2 trading dates. Found {len(dates)} date(s)."
        })
        return

    # market snapshot map
    mkt_map: Dict[str, dict] = {}
    mkt_path = os.path.join(ROOT, args.market_csv)
    if os.path.exists(mkt_path):
        mkt = read_csv(mkt_path)
        mkt["date"] = mkt["date"].astype(str)
        for _, r in mkt.iterrows():
            mkt_map[str(r["date"])] = {
                "risk_mode": str(r.get("risk_mode","RISK_OFF")),
                "market_ok": safe_bool(r.get("market_ok", False)),
                "trend_ok": safe_bool(r.get("trend_ok", False)),
            }

    equity = float(args.init_capital)
    held: Set[str] = set()
    rows: List[dict] = []
    daily_net: List[float] = []
    cost_rate = float(args.cost_bps) / 10000.0

    for i in range(len(dates) - 1):
        d0 = dates[i]
        d1 = dates[i + 1]

        snap = mkt_map.get(d0, None)
        risk_mode = snap["risk_mode"] if snap else "RISK_OFF"
        market_ok = snap["market_ok"] if snap else False
        trend_ok = snap["trend_ok"] if snap else False

        target_n = int(args.holdings_on if market_ok else args.holdings_off)
        target_n = max(0, target_n)

        day0 = df[df["date"] == d0].copy().sort_values("total_score", ascending=False)
        day1 = df[df["date"] == d1].copy()

        if target_n > 0:
            selected = day0.head(target_n)["code"].astype(str).tolist()
            new_held = set(selected)
        else:
            new_held = set()

        if len(held) == 0 and len(new_held) == 0:
            turnover = 0.0
        else:
            diff = len(held.symmetric_difference(new_held))
            denom = max(1, max(len(held), len(new_held)) * 2)
            turnover = diff / denom

        if len(new_held) > 0:
            day1_map = dict(zip(day1["code"].astype(str), day1["change_percent"].astype(float)))
            rets = [day1_map.get(c, 0.0) / 100.0 for c in new_held]
            gross = float(np.mean(rets)) if rets else 0.0
        else:
            gross = 0.0

        cost_frac = float(turnover) * cost_rate
        net = gross - cost_frac
        equity = equity * (1.0 + net)

        rows.append({
            "date": d1,
            "prev_date": d0,
            "risk_mode": risk_mode,
            "market_ok": bool(market_ok),
            "trend_ok": bool(trend_ok),
            "breadth_ratio": 0.0,
            "holdings": int(len(new_held)),
            "turnover": float(turnover),
            "gross_return": float(gross),
            "cost_frac": float(cost_frac),
            "net_return": float(net),
            "equity": float(equity),
        })
        daily_net.append(net)
        held = new_held

    out = pd.DataFrame(rows)
    write_csv(os.path.join(ROOT, args.out_csv), out)

    eq = out["equity"].astype(float).to_numpy()
    dr = np.array(daily_net, dtype=float)
    total_return = (eq[-1] / args.init_capital) - 1.0 if eq.size else 0.0
    ann = (1.0 + total_return) ** (252.0 / max(1, len(dr))) - 1.0 if dr.size else 0.0

    summary = {
        "init_capital": float(args.init_capital),
        "final_equity": float(eq[-1]) if eq.size else float(args.init_capital),
        "total_return": float(total_return),
        "annualized_return": float(ann),
        "max_drawdown": float(compute_max_drawdown(eq)),
        "sharpe": float(compute_sharpe(dr)),
        "bars": int(len(dr)),
    }
    write_json(os.path.join(ROOT, args.out_json), summary)
    print("=== PORTFOLIO v3 DONE ===")
    print(f"bars={summary['bars']} final_equity={summary['final_equity']:.2f} total_return={summary['total_return']:.4f}")

if __name__ == "__main__":
    main()